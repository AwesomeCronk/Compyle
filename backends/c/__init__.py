import dis, logging
from types import CodeType


indentSize = 4
NoneType = type(None)

log = logging.getLogger('instr')
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)

class codeBlock:
    def __init__(self, indent, header):
        self.indent = indent
        self.header = header
        self.code = []

    def compile(self):
        indentStr = ' ' * indentSize * self.indent
        result = [indentStr + self.header]
        result.append(indentStr + '{')

        for line in self.code:
            result.append(indentStr + ' ' * indentSize + line)

        result.append(indentStr + '}')
        return '\n'.join(result)

class cProgram:
    def __init__(self):
        self.description = []   # Contains comments describing things
        self.definitions = []   # Contains function definitions
        self.code = []          # Contains code block objects

    def build(self):
        result  = '\n'.join(self.description).encode() + b'\n' \
                + '\n'.join(self.definitions).encode() + b'\n' \
                + '\n'.join(self.code).encode() + b'\n'
        return result


class opcodeProcessor:

    from ._opcodeHandlers.binaryOps import (
        BINARY_MATRIX_MULTIPLY,
        INPLACE_MATRIX_MULTIPLY,
        BINARY_POWER,
        BINARY_MULTIPLY,
        BINARY_MODULO,
        BINARY_ADD,
        BINARY_SUBTRACT,
        BINARY_SUBSCR,
        BINARY_FLOOR_DIVIDE,
        BINARY_TRUE_DIVIDE
    )
    from ._opcodeHandlers.build import (
        BUILD_TUPLE,
        BUILD_LIST,
        BUILD_SET,
        BUILD_MAP,
        BUILD_SLICE,
        BUILD_LIST_UNPACK,
        BUILD_MAP_UNPACK,
        BUILD_MAP_UNPACK_WITH_CALL,
        BUILD_TUPLE_UNPACK,
        BUILD_SET_UNPACK,
        BUILD_CONST_KEY_MAP,
        BUILD_STRING,
        BUILD_TUPLE_UNPACK_WITH_CALL
    )
    from ._opcodeHandlers.inplaceOps import (
        INPLACE_FLOOR_DIVIDE,
        INPLACE_TRUE_DIVIDE,
        INPLACE_ADD,
        INPLACE_SUBTRACT,
        INPLACE_MULTIPLY,
        INPLACE_MODULO,
        INPLACE_POWER,
        INPLACE_LSHIFT,
        INPLACE_RSHIFT,
        INPLACE_AND,
        INPLACE_XOR,
        INPLACE_OR
    )
    from ._opcodeHandlers.misc import (
        NOP,
        GET_AITER,
        GET_ANEXT,
        BEFORE_ASYNC_WITH,
        BEGIN_FINALLY,
        END_ASYNC_FOR,
        STORE_SUBSCR,
        DELETE_SUBSCR,
        GET_ITER,
        GET_YIELD_FROM_ITER,
        PRINT_EXPR,
        LOAD_BUILD_CLASS,
        YIELD_FROM,
        GET_AWAITABLE,
        WITH_CLEANUP_START,
        WITH_CLEANUP_FINISH,
        RETURN_VALUE,
        IMPORT_STAR,
        SETUP_ANNOTATIONS,
        YIELD_VALUE,
        POP_BLOCK,
        END_FINALLY,
        POP_EXCEPT,
        STORE_NAME,
        DELETE_NAME,
        UNPACK_SEQUENCE,
        FOR_ITER,
        UNPACK_EX,
        STORE_ATTR,
        DELETE_ATTR,
        STORE_GLOBAL,
        DELETE_GLOBAL,
        LOAD_CONST,
        LOAD_NAME,
        LOAD_ATTR,
        COMPARE_OP,
        IMPORT_NAME,
        IMPORT_FROM,
        JUMP_FORWARD,
        JUMP_IF_FALSE_OR_POP,
        JUMP_IF_TRUE_OR_POP,
        JUMP_ABSOLUTE,
        POP_JUMP_IF_FALSE,
        POP_JUMP_IF_TRUE,
        LOAD_GLOBAL,
        SETUP_FINALLY,
        LOAD_FAST,
        STORE_FAST,
        DELETE_FAST,
        RAISE_VARARGS,
        CALL_FUNCTION,
        MAKE_FUNCTION,
        LOAD_CLOSURE,
        LOAD_DEREF,
        STORE_DEREF,
        DELETE_DEREF,
        CALL_FUNCTION_KW,
        CALL_FUNCTION_EX,
        SETUP_WITH,
        EXTENDED_ARG,
        LIST_APPEND,
        SET_ADD,
        MAP_ADD,
        LOAD_CLASSDEREF,
        SETUP_ASYNC_WITH,
        FORMAT_VALUE,
        LOAD_METHOD,
        CALL_METHOD,
        CALL_FINALLY,
        POP_FINALLY
    )
    from ._opcodeHandlers.stack import (
        POP_TOP,
        ROT_TWO,
        ROT_THREE,
        DUP_TOP,
        DUP_TOP_TWO,
        ROT_FOUR
    )
    from ._opcodeHandlers.unaryOps import (
        UNARY_POSITIVE,
        UNARY_NEGATIVE,
        UNARY_NOT,
        UNARY_INVERT
    )

    def __init__(self, codeObject, metadata):
        self.codeObject = codeObject
        self.metadata = metadata
        self.simStack = []          # Simulated stack to predict data movement through the CPython stack
        self.nameMap = {}           # Map of names to predict data movement through named objects
        self.program = cProgram()   # Object that organizes the resulting program
        self.log = logging.getLogger('opcode')

    def processCode(self):
        instrs = dis.get_instructions(self.codeObject)

        self.program.description.append('// Generated by Compyle')    # List of output lines

        for key in self.metadata.keys():
            self.program.description.append('// {}: {}'.format(key, self.metadata[key]))

        self.program.code.append('int main()')
        self.program.code.append('{')

        for instrNum, instr in enumerate(instrs):
            self.log.debug('{} {}'.format(instr.opname, instr.arg))

            try:
                opcodeHandler = getattr(self, instr.opname)
            except:
                raise ValueError('Opcode {} not recognized'.format(instr.opname))

            opcodeHandler(instr)


            log.debug('Stack:')
            for i in range(len(self.simStack)):
                log.debug('  {}'.format(self.simStack[-i - 1]))

        self.program.code.append('}')
        return self.program.build()


# Entry point to the C backend
def process(codeObject: CodeType, metadata: dict):
    processor = opcodeProcessor(codeObject, metadata)
    result = processor.processCode()
    return result
