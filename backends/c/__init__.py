import dis, logging
from types import CodeType


NoneType = type(None)

log = logging.getLogger('instr')
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)

class object:
    def __init__(self, representation):
        self.representation = representation

class constant(object):
    def __init__(self, knownType, representation):
        object.__init__(self, representation)
        self.knownType = knownType

    def __str__(self):
        return 'constant({}, {})'.format(self.knownType, repr(self.representation))
    
    __repr__ = __str__

class variable(object):
    def __init__(self, possibleTypes, representation):
        object.__init__(self, representation)
        self.possibleTypes = possibleTypes

    def __str__(self):
        return 'variable({}, {})'.format(self.possibleTypes, repr(self.representation))
    
    __repr__ = __str__

class processor:
    def __init__(self):
        pass

    from ._opcodeHandlers.binaryOps import (
        BINARY_MATRIX_MULTIPLY,
        INPLACE_MATRIX_MULTIPLY,
        BINARY_POWER,
        BINARY_MULTIPLY,
        BINARY_MODULO,
        BINARY_ADD,
        BINARY_SUBTRACT,
        BINARY_SUBSCR,
        BINARY_FLOOR_DIVIDE,
        BINARY_TRUE_DIVIDE
    )
    from ._opcodeHandlers.build import (
        BUILD_TUPLE,
        BUILD_LIST,
        BUILD_SET,
        BUILD_MAP,
        BUILD_SLICE,
        BUILD_LIST_UNPACK,
        BUILD_MAP_UNPACK,
        BUILD_MAP_UNPACK_WITH_CALL,
        BUILD_TUPLE_UNPACK,
        BUILD_SET_UNPACK,
        BUILD_CONST_KEY_MAP,
        BUILD_STRING,
        BUILD_TUPLE_UNPACK_WITH_CALL
    )
    from ._opcodeHandlers.inplaceOps import (
        INPLACE_FLOOR_DIVIDE,
        INPLACE_TRUE_DIVIDE,
        INPLACE_ADD,
        INPLACE_SUBTRACT,
        INPLACE_MULTIPLY,
        INPLACE_MODULO,
        INPLACE_POWER,
        INPLACE_LSHIFT,
        INPLACE_RSHIFT,
        INPLACE_AND,
        INPLACE_XOR,
        INPLACE_OR
    )
    from ._opcodeHandlers.misc import (
        NOP,
        GET_AITER,
        GET_ANEXT,
        BEFORE_ASYNC_WITH,
        BEGIN_FINALLY,
        END_ASYNC_FOR,
        STORE_SUBSCR,
        DELETE_SUBSCR,
        GET_ITER,
        GET_YIELD_FROM_ITER,
        PRINT_EXPR,
        LOAD_BUILD_CLASS,
        YIELD_FROM,
        GET_AWAITABLE,
        WITH_CLEANUP_START,
        WITH_CLEANUP_FINISH,
        RETURN_VALUE,
        IMPORT_STAR,
        SETUP_ANNOTATIONS,
        YIELD_VALUE,
        POP_BLOCK,
        END_FINALLY,
        POP_EXCEPT,
        STORE_NAME,
        DELETE_NAME,
        UNPACK_SEQUENCE,
        FOR_ITER,
        UNPACK_EX,
        STORE_ATTR,
        DELETE_ATTR,
        STORE_GLOBAL,
        DELETE_GLOBAL,
        LOAD_CONST,
        LOAD_NAME,
        LOAD_ATTR,
        COMPARE_OP,
        IMPORT_NAME,
        IMPORT_FROM,
        JUMP_FORWARD,
        JUMP_IF_FALSE_OR_POP,
        JUMP_IF_TRUE_OR_POP,
        JUMP_ABSOLUTE,
        POP_JUMP_IF_FALSE,
        POP_JUMP_IF_TRUE,
        LOAD_GLOBAL,
        SETUP_FINALLY,
        LOAD_FAST,
        STORE_FAST,
        DELETE_FAST,
        RAISE_VARARGS,
        CALL_FUNCTION,
        MAKE_FUNCTION,
        LOAD_CLOSURE,
        LOAD_DEREF,
        STORE_DEREF,
        DELETE_DEREF,
        CALL_FUNCTION_KW,
        CALL_FUNCTION_EX,
        SETUP_WITH,
        EXTENDED_ARG,
        LIST_APPEND,
        SET_ADD,
        MAP_ADD,
        LOAD_CLASSDEREF,
        SETUP_ASYNC_WITH,
        FORMAT_VALUE,
        LOAD_METHOD,
        CALL_METHOD,
        CALL_FINALLY,
        POP_FINALLY
    )
    from ._opcodeHandlers.stack import (
        POP_TOP,
        ROT_TWO,
        ROT_THREE,
        DUP_TOP,
        DUP_TOP_TWO,
        ROT_FOUR
    )
    from ._opcodeHandlers.unaryOps import (
        UNARY_POSITIVE,
        UNARY_NEGATIVE,
        UNARY_NOT,
        UNARY_INVERT
    )


def process(codeObject: CodeType, metadata: dict):
    instrs = dis.get_instructions(codeObject)

    simStack = []   # Simulated stack to predict data movement through the CPython stack
    nameMap = {}    # Map of names to predict data movement through named objects

    cProgram = ['// Generated by Compyle']   # List of output lines

    for key in metadata.keys():
        cProgram.append('// {}: {}'.format(key, metadata[key]))

    cProgram.append('int main()')
    cProgram.append('{')

    for instrNum, instr in enumerate(instrs):
        log.debug('{} {}'.format(instr.opname, instr.arg))

        try:
            opcodeHandler = getattr(currentProcessor, instr.opname)

        except:
            raise ValueError('Opcode {} not recognized'.format(instr.opname))


        log.debug('Stack:')
        for i in range(len(simStack)):
            log.debug('  {}'.format(simStack[-i - 1]))

    cProgram.append('}')
    return '\n'.join(cProgram).encode() + b'\n'
